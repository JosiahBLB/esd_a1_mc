
esd_assignment_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000406  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000392  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000d  00800100  00800100  00000406  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000406  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000438  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  00000478  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000010c8  00000000  00000000  000004f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d6a  00000000  00000000  000015c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005bd  00000000  00000000  0000232a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000f4  00000000  00000000  000028e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000638  00000000  00000000  000029dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000010b  00000000  00000000  00003014  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000050  00000000  00000000  0000311f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	59 c0       	rjmp	.+178    	; 0xb4 <__ctors_end>
   2:	00 00       	nop
   4:	67 c0       	rjmp	.+206    	; 0xd4 <__bad_interrupt>
   6:	00 00       	nop
   8:	65 c0       	rjmp	.+202    	; 0xd4 <__bad_interrupt>
   a:	00 00       	nop
   c:	63 c0       	rjmp	.+198    	; 0xd4 <__bad_interrupt>
   e:	00 00       	nop
  10:	61 c0       	rjmp	.+194    	; 0xd4 <__bad_interrupt>
  12:	00 00       	nop
  14:	5f c0       	rjmp	.+190    	; 0xd4 <__bad_interrupt>
  16:	00 00       	nop
  18:	5d c0       	rjmp	.+186    	; 0xd4 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	5b c0       	rjmp	.+182    	; 0xd4 <__bad_interrupt>
  1e:	00 00       	nop
  20:	59 c0       	rjmp	.+178    	; 0xd4 <__bad_interrupt>
  22:	00 00       	nop
  24:	57 c0       	rjmp	.+174    	; 0xd4 <__bad_interrupt>
  26:	00 00       	nop
  28:	55 c0       	rjmp	.+170    	; 0xd4 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	53 c0       	rjmp	.+166    	; 0xd4 <__bad_interrupt>
  2e:	00 00       	nop
  30:	51 c0       	rjmp	.+162    	; 0xd4 <__bad_interrupt>
  32:	00 00       	nop
  34:	4f c0       	rjmp	.+158    	; 0xd4 <__bad_interrupt>
  36:	00 00       	nop
  38:	4d c0       	rjmp	.+154    	; 0xd4 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	4b c0       	rjmp	.+150    	; 0xd4 <__bad_interrupt>
  3e:	00 00       	nop
  40:	49 c0       	rjmp	.+146    	; 0xd4 <__bad_interrupt>
  42:	00 00       	nop
  44:	47 c0       	rjmp	.+142    	; 0xd4 <__bad_interrupt>
  46:	00 00       	nop
  48:	45 c0       	rjmp	.+138    	; 0xd4 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	43 c0       	rjmp	.+134    	; 0xd4 <__bad_interrupt>
  4e:	00 00       	nop
  50:	41 c0       	rjmp	.+130    	; 0xd4 <__bad_interrupt>
  52:	00 00       	nop
  54:	3f c0       	rjmp	.+126    	; 0xd4 <__bad_interrupt>
  56:	00 00       	nop
  58:	3d c0       	rjmp	.+122    	; 0xd4 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	3b c0       	rjmp	.+118    	; 0xd4 <__bad_interrupt>
  5e:	00 00       	nop
  60:	39 c0       	rjmp	.+114    	; 0xd4 <__bad_interrupt>
  62:	00 00       	nop
  64:	e0 c0       	rjmp	.+448    	; 0x226 <__vector_25>
  66:	00 00       	nop
  68:	35 c0       	rjmp	.+106    	; 0xd4 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	33 c0       	rjmp	.+102    	; 0xd4 <__bad_interrupt>
  6e:	00 00       	nop
  70:	31 c0       	rjmp	.+98     	; 0xd4 <__bad_interrupt>
  72:	00 00       	nop
  74:	2f c0       	rjmp	.+94     	; 0xd4 <__bad_interrupt>
  76:	00 00       	nop
  78:	2d c0       	rjmp	.+90     	; 0xd4 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	2b c0       	rjmp	.+86     	; 0xd4 <__bad_interrupt>
  7e:	00 00       	nop
  80:	29 c0       	rjmp	.+82     	; 0xd4 <__bad_interrupt>
  82:	00 00       	nop
  84:	27 c0       	rjmp	.+78     	; 0xd4 <__bad_interrupt>
  86:	00 00       	nop
  88:	25 c0       	rjmp	.+74     	; 0xd4 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	23 c0       	rjmp	.+70     	; 0xd4 <__bad_interrupt>
  8e:	00 00       	nop
  90:	21 c0       	rjmp	.+66     	; 0xd4 <__bad_interrupt>
  92:	00 00       	nop
  94:	1f c0       	rjmp	.+62     	; 0xd4 <__bad_interrupt>
  96:	00 00       	nop
  98:	77 00       	.word	0x0077	; ????
  9a:	7a 00       	.word	0x007a	; ????
  9c:	7d 00       	.word	0x007d	; ????
  9e:	80 00       	.word	0x0080	; ????
  a0:	83 00       	.word	0x0083	; ????
  a2:	86 00       	.word	0x0086	; ????
  a4:	d9 00       	.word	0x00d9	; ????
  a6:	d9 00       	.word	0x00d9	; ????
  a8:	d9 00       	.word	0x00d9	; ????
  aa:	d9 00       	.word	0x00d9	; ????
  ac:	89 00       	.word	0x0089	; ????
  ae:	91 00       	.word	0x0091	; ????
  b0:	a8 00       	.word	0x00a8	; ????
  b2:	c1 00       	.word	0x00c1	; ????

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf ef       	ldi	r28, 0xFF	; 255
  ba:	d0 e2       	ldi	r29, 0x20	; 32
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_clear_bss>:
  c0:	21 e0       	ldi	r18, 0x01	; 1
  c2:	a0 e0       	ldi	r26, 0x00	; 0
  c4:	b1 e0       	ldi	r27, 0x01	; 1
  c6:	01 c0       	rjmp	.+2      	; 0xca <.do_clear_bss_start>

000000c8 <.do_clear_bss_loop>:
  c8:	1d 92       	st	X+, r1

000000ca <.do_clear_bss_start>:
  ca:	ad 30       	cpi	r26, 0x0D	; 13
  cc:	b2 07       	cpc	r27, r18
  ce:	e1 f7       	brne	.-8      	; 0xc8 <.do_clear_bss_loop>
  d0:	a3 d0       	rcall	.+326    	; 0x218 <main>
  d2:	5d c1       	rjmp	.+698    	; 0x38e <_exit>

000000d4 <__bad_interrupt>:
  d4:	95 cf       	rjmp	.-214    	; 0x0 <__vectors>

000000d6 <executeInstruction>:
#include "instructions.h"


void executeInstruction()
{
	switch (instruction)
  d6:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <instruction>
  da:	8e 2f       	mov	r24, r30
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	8e 30       	cpi	r24, 0x0E	; 14
  e0:	91 05       	cpc	r25, r1
  e2:	08 f0       	brcs	.+2      	; 0xe6 <executeInstruction+0x10>
  e4:	66 c0       	rjmp	.+204    	; 0x1b2 <executeInstruction+0xdc>
  e6:	fc 01       	movw	r30, r24
  e8:	e4 5b       	subi	r30, 0xB4	; 180
  ea:	ff 4f       	sbci	r31, 0xFF	; 255
  ec:	47 c1       	rjmp	.+654    	; 0x37c <__tablejump2__>
	{
	case TX_CHECK:
		sendUsart(TX_CHECK);
  ee:	80 e0       	ldi	r24, 0x00	; 0
  f0:	2f d1       	rcall	.+606    	; 0x350 <sendUsart>
		break;
	
	// Sends back PINA
	case READ_PINA:
		sendUsart(PINA);
  f2:	5f c0       	rjmp	.+190    	; 0x1b2 <executeInstruction+0xdc>
  f4:	80 b1       	in	r24, 0x00	; 0
		break;
  f6:	2c d1       	rcall	.+600    	; 0x350 <sendUsart>
	
	// Sends back the ADC values	
	case READ_POT1:
		sendAdcUsart(pot1); 
  f8:	5c c0       	rjmp	.+184    	; 0x1b2 <executeInstruction+0xdc>
  fa:	82 e6       	ldi	r24, 0x62	; 98
		break;
  fc:	30 d1       	rcall	.+608    	; 0x35e <sendAdcUsart>
		
	case READ_POT2:
		sendAdcUsart(pot2);
  fe:	59 c0       	rjmp	.+178    	; 0x1b2 <executeInstruction+0xdc>
 100:	81 e6       	ldi	r24, 0x61	; 97
		break;
		
	case READ_TEMP:
		sendAdcUsart(tempSensor);
 102:	2d d1       	rcall	.+602    	; 0x35e <sendAdcUsart>
 104:	56 c0       	rjmp	.+172    	; 0x1b2 <executeInstruction+0xdc>
 106:	83 e6       	ldi	r24, 0x63	; 99
		break;
 108:	2a d1       	rcall	.+596    	; 0x35e <sendAdcUsart>
		
	case READ_LDR:
		sendAdcUsart(lightSensor);
 10a:	53 c0       	rjmp	.+166    	; 0x1b2 <executeInstruction+0xdc>
 10c:	80 e6       	ldi	r24, 0x60	; 96
 10e:	27 d1       	rcall	.+590    	; 0x35e <sendAdcUsart>
		break;
	
	// Sets Peripherals	and returns instruction
	case SET_PORTC:
		PORTC = setValue;
 110:	50 c0       	rjmp	.+160    	; 0x1b2 <executeInstruction+0xdc>
 112:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <setValue>
 116:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <setValue+0x1>
		sendUsart(SET_PORTC);
 11a:	88 b9       	out	0x08, r24	; 8
 11c:	8a e0       	ldi	r24, 0x0A	; 10
 11e:	18 d1       	rcall	.+560    	; 0x350 <sendUsart>
		break;
 120:	48 c0       	rjmp	.+144    	; 0x1b2 <executeInstruction+0xdc>
		
	case SET_HEATER:
		if(setValue > 0)
 122:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <setValue>
 126:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <setValue+0x1>
 12a:	18 16       	cp	r1, r24
 12c:	19 06       	cpc	r1, r25
 12e:	24 f4       	brge	.+8      	; 0x138 <executeInstruction+0x62>
			heaterOn;
 130:	84 b1       	in	r24, 0x04	; 4
 132:	80 68       	ori	r24, 0x80	; 128
 134:	84 b9       	out	0x04, r24	; 4
 136:	03 c0       	rjmp	.+6      	; 0x13e <executeInstruction+0x68>
		else
			heaterOff;
 138:	84 b1       	in	r24, 0x04	; 4
 13a:	8f 77       	andi	r24, 0x7F	; 127
		OCR1C = 49;
 13c:	84 b9       	out	0x04, r24	; 4
 13e:	81 e3       	ldi	r24, 0x31	; 49
 140:	90 e0       	ldi	r25, 0x00	; 0
 142:	90 93 8d 00 	sts	0x008D, r25	; 0x80008d <__TEXT_REGION_LENGTH__+0x7e008d>
 146:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <__TEXT_REGION_LENGTH__+0x7e008c>
		sendUsart(SET_HEATER);
 14a:	8b e0       	ldi	r24, 0x0B	; 11
 14c:	01 d1       	rcall	.+514    	; 0x350 <sendUsart>
		break;
 14e:	31 c0       	rjmp	.+98     	; 0x1b2 <executeInstruction+0xdc>
		
	case SET_LAMP:
		if(setValue > 0)
 150:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <setValue>
 154:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <setValue+0x1>
 158:	18 16       	cp	r1, r24
 15a:	19 06       	cpc	r1, r25
 15c:	24 f4       	brge	.+8      	; 0x166 <executeInstruction+0x90>
			lampOn;
 15e:	84 b1       	in	r24, 0x04	; 4
 160:	80 64       	ori	r24, 0x40	; 64
 162:	84 b9       	out	0x04, r24	; 4
 164:	03 c0       	rjmp	.+6      	; 0x16c <executeInstruction+0x96>
		else
			lampOff;
 166:	84 b1       	in	r24, 0x04	; 4
 168:	8f 7b       	andi	r24, 0xBF	; 191
 16a:	84 b9       	out	0x04, r24	; 4
		OCR1B = setValue;
 16c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <setValue>
 170:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <setValue+0x1>
 174:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
 178:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
		sendUsart(SET_LAMP);
 17c:	8c e0       	ldi	r24, 0x0C	; 12
 17e:	e8 d0       	rcall	.+464    	; 0x350 <sendUsart>
		break;
 180:	18 c0       	rjmp	.+48     	; 0x1b2 <executeInstruction+0xdc>
		
	case SET_MOTOR:
		if(setValue > 0)
 182:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <setValue>
 186:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <setValue+0x1>
 18a:	18 16       	cp	r1, r24
 18c:	19 06       	cpc	r1, r25
 18e:	24 f4       	brge	.+8      	; 0x198 <executeInstruction+0xc2>
			motorOn;
 190:	84 b1       	in	r24, 0x04	; 4
 192:	80 62       	ori	r24, 0x20	; 32
 194:	84 b9       	out	0x04, r24	; 4
 196:	03 c0       	rjmp	.+6      	; 0x19e <executeInstruction+0xc8>
		else
			motorOff;
 198:	84 b1       	in	r24, 0x04	; 4
 19a:	8f 7d       	andi	r24, 0xDF	; 223
		OCR1A = setValue;
 19c:	84 b9       	out	0x04, r24	; 4
 19e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <setValue>
 1a2:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <setValue+0x1>
 1a6:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 1aa:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
		sendUsart(SET_MOTOR);
 1ae:	8d e0       	ldi	r24, 0x0D	; 13
 1b0:	cf d0       	rcall	.+414    	; 0x350 <sendUsart>
		break;
		
	default:
		break;
	}
	instruction = DEFAULT; // Clear instruction on completion
 1b2:	8f ef       	ldi	r24, 0xFF	; 255
 1b4:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <instruction>
	execute_instruction = FALSE; // reset flag to false
 1b8:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <execute_instruction>
 1bc:	08 95       	ret

000001be <setup>:
    }
}

void setup(void)
{
	cli(); // Clear interrupts
 1be:	f8 94       	cli
	
	// I/O
	DDRC = 0xFF;
 1c0:	8f ef       	ldi	r24, 0xFF	; 255
 1c2:	87 b9       	out	0x07, r24	; 7
	DDRA = 0x00;
 1c4:	11 b8       	out	0x01, r1	; 1
	DDRE = 0x03;
 1c6:	93 e0       	ldi	r25, 0x03	; 3
 1c8:	9d b9       	out	0x0d, r25	; 13
	PORTE = 0x00;
 1ca:	1e b8       	out	0x0e, r1	; 14
	
	// USART
	UCSR1B = 0b10011000;//enable receiver and it's interrupt
 1cc:	98 e9       	ldi	r25, 0x98	; 152
 1ce:	90 93 c9 00 	sts	0x00C9, r25	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
	UCSR1C = 0b00000110;//1 stop bit, 8 bit character size, no parity bits
 1d2:	96 e0       	ldi	r25, 0x06	; 6
 1d4:	90 93 ca 00 	sts	0x00CA, r25	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
	UBRR1L = 12;//Baud rate set to 38400
 1d8:	9c e0       	ldi	r25, 0x0C	; 12
 1da:	90 93 cc 00 	sts	0x00CC, r25	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
	
	// ADC
	ADMUX = 0x01100000;
 1de:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	ADCSRA = 0b11000111; // Enable ADC, start conversion, free running mode, slowest speed
 1e2:	97 ec       	ldi	r25, 0xC7	; 199
 1e4:	90 93 7a 00 	sts	0x007A, r25	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

	// 16-bit timer
	TCCR1A = 0b10101010; // A, B and C fast PWM, ICR1 as top
 1e8:	9a ea       	ldi	r25, 0xAA	; 170
 1ea:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
	TCCR1B = 0b00011010; // ICR1 as top, div 8 pre-scaling
 1ee:	9a e1       	ldi	r25, 0x1A	; 26
 1f0:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	ICR1 = 49; // 20kHz
 1f4:	21 e3       	ldi	r18, 0x31	; 49
 1f6:	30 e0       	ldi	r19, 0x00	; 0
 1f8:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
 1fc:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	
	// Initialize variables
	instruction = DEFAULT;
 200:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <instruction>
	execute_instruction = FALSE;
 204:	10 92 0b 01 	sts	0x010B, r1	; 0x80010b <execute_instruction>
	p_buffer = &buffer;
 208:	85 e0       	ldi	r24, 0x05	; 5
 20a:	91 e0       	ldi	r25, 0x01	; 1
 20c:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 210:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
		
	sei(); // Set interrupts
 214:	78 94       	sei
 216:	08 95       	ret

00000218 <main>:
#include "instructions.h"


int main(void)
{	
    setup();
 218:	d2 df       	rcall	.-92     	; 0x1be <setup>
    while (1) 
    {
		if (execute_instruction) // flag to see if instruction should be executed
 21a:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <execute_instruction>
 21e:	88 23       	and	r24, r24
		{
			executeInstruction();
 220:	e1 f3       	breq	.-8      	; 0x21a <main+0x2>
 222:	59 df       	rcall	.-334    	; 0xd6 <executeInstruction>
 224:	fa cf       	rjmp	.-12     	; 0x21a <main+0x2>

00000226 <__vector_25>:
		
	sei(); // Set interrupts
}

ISR(USART1_RX_vect)
{
 226:	1f 92       	push	r1
 228:	0f 92       	push	r0
 22a:	0f b6       	in	r0, 0x3f	; 63
 22c:	0f 92       	push	r0
 22e:	11 24       	eor	r1, r1
 230:	0b b6       	in	r0, 0x3b	; 59
 232:	0f 92       	push	r0
 234:	2f 93       	push	r18
 236:	3f 93       	push	r19
 238:	4f 93       	push	r20
 23a:	5f 93       	push	r21
 23c:	6f 93       	push	r22
 23e:	7f 93       	push	r23
 240:	8f 93       	push	r24
 242:	9f 93       	push	r25
 244:	af 93       	push	r26
 246:	bf 93       	push	r27
 248:	ef 93       	push	r30
 24a:	ff 93       	push	r31
	readUsart();
 24c:	13 d0       	rcall	.+38     	; 0x274 <readUsart>
 24e:	ff 91       	pop	r31
 250:	ef 91       	pop	r30
 252:	bf 91       	pop	r27
 254:	af 91       	pop	r26
 256:	9f 91       	pop	r25
 258:	8f 91       	pop	r24
 25a:	7f 91       	pop	r23
 25c:	6f 91       	pop	r22
 25e:	5f 91       	pop	r21
 260:	4f 91       	pop	r20
 262:	3f 91       	pop	r19
 264:	2f 91       	pop	r18
 266:	0f 90       	pop	r0
 268:	0b be       	out	0x3b, r0	; 59
 26a:	0f 90       	pop	r0
 26c:	0f be       	out	0x3f, r0	; 63
 26e:	0f 90       	pop	r0
 270:	1f 90       	pop	r1
 272:	18 95       	reti

00000274 <readUsart>:
#include "usart.h"


void readUsart(void)
{
	*p_buffer = UDR1; // Save byte
 274:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 278:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 27c:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
 280:	80 83       	st	Z, r24
	switch (rxState)
 282:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <rxState>
 286:	88 23       	and	r24, r24
 288:	19 f0       	breq	.+6      	; 0x290 <readUsart+0x1c>
 28a:	81 30       	cpi	r24, 0x01	; 1
 28c:	91 f0       	breq	.+36     	; 0x2b2 <readUsart+0x3e>
 28e:	08 95       	ret
	{
		case IDLE: 
		if (*p_buffer == START_BYTE) // Wait for a start byte
 290:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 294:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 298:	80 81       	ld	r24, Z
 29a:	83 35       	cpi	r24, 0x53	; 83
 29c:	09 f0       	breq	.+2      	; 0x2a0 <readUsart+0x2c>
 29e:	57 c0       	rjmp	.+174    	; 0x34e <readUsart+0xda>
		{
			rxState = READ;
 2a0:	81 e0       	ldi	r24, 0x01	; 1
 2a2:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <rxState>
			p_buffer++;
 2a6:	31 96       	adiw	r30, 0x01	; 1
 2a8:	f0 93 01 01 	sts	0x0101, r31	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 2ac:	e0 93 00 01 	sts	0x0100, r30	; 0x800100 <__DATA_REGION_ORIGIN__>
 2b0:	08 95       	ret
		}
		break;
			
		case READ: // [start][instr][msb][lsb][stop][\0]
		if ((p_buffer == &buffer[4]) || (*p_buffer == STOP_BYTE)) // If at end of the array or byte is the stop byte
 2b2:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 2b6:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 2ba:	81 e0       	ldi	r24, 0x01	; 1
 2bc:	e9 30       	cpi	r30, 0x09	; 9
 2be:	f8 07       	cpc	r31, r24
 2c0:	19 f0       	breq	.+6      	; 0x2c8 <readUsart+0x54>
 2c2:	80 81       	ld	r24, Z
 2c4:	8a 3a       	cpi	r24, 0xAA	; 170
 2c6:	f1 f5       	brne	.+124    	; 0x344 <readUsart+0xd0>
		{
			if (buffer[2] == STOP_BYTE) // Instruction only
 2c8:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <buffer+0x2>
 2cc:	8a 3a       	cpi	r24, 0xAA	; 170
 2ce:	29 f4       	brne	.+10     	; 0x2da <readUsart+0x66>
			{
				instruction = buffer[1];
 2d0:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <buffer+0x1>
 2d4:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <instruction>
 2d8:	24 c0       	rjmp	.+72     	; 0x322 <readUsart+0xae>
			}
			else if (buffer[3] == STOP_BYTE) // Instruction and one byte
 2da:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <buffer+0x3>
 2de:	8a 3a       	cpi	r24, 0xAA	; 170
 2e0:	61 f4       	brne	.+24     	; 0x2fa <readUsart+0x86>
			{
				instruction = buffer[1];
 2e2:	e5 e0       	ldi	r30, 0x05	; 5
 2e4:	f1 e0       	ldi	r31, 0x01	; 1
 2e6:	81 81       	ldd	r24, Z+1	; 0x01
 2e8:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <instruction>
				setValue = buffer[2];
 2ec:	82 81       	ldd	r24, Z+2	; 0x02
 2ee:	90 e0       	ldi	r25, 0x00	; 0
 2f0:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <setValue+0x1>
 2f4:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <setValue>
 2f8:	14 c0       	rjmp	.+40     	; 0x322 <readUsart+0xae>
			}
			else if (buffer[4] == STOP_BYTE) // Instruction and two bytes
 2fa:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <buffer+0x4>
 2fe:	8a 3a       	cpi	r24, 0xAA	; 170
 300:	81 f4       	brne	.+32     	; 0x322 <readUsart+0xae>
			{
				instruction = buffer[1];
 302:	e5 e0       	ldi	r30, 0x05	; 5
 304:	f1 e0       	ldi	r31, 0x01	; 1
 306:	81 81       	ldd	r24, Z+1	; 0x01
 308:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <instruction>
				setValue = (buffer[2] << 8) + buffer[3];
 30c:	82 81       	ldd	r24, Z+2	; 0x02
 30e:	90 e0       	ldi	r25, 0x00	; 0
 310:	98 2f       	mov	r25, r24
 312:	88 27       	eor	r24, r24
 314:	23 81       	ldd	r18, Z+3	; 0x03
 316:	82 0f       	add	r24, r18
 318:	91 1d       	adc	r25, r1
 31a:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <setValue+0x1>
 31e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <setValue>
			}
			execute_instruction = TRUE; // Set flag to true
 322:	81 e0       	ldi	r24, 0x01	; 1
 324:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <execute_instruction>
				
			// Reset
			memset(buffer, 0, 6*sizeof(uint8_t)); // Clear the buffer
 328:	e5 e0       	ldi	r30, 0x05	; 5
 32a:	f1 e0       	ldi	r31, 0x01	; 1
 32c:	86 e0       	ldi	r24, 0x06	; 6
 32e:	df 01       	movw	r26, r30
 330:	1d 92       	st	X+, r1
 332:	8a 95       	dec	r24
 334:	e9 f7       	brne	.-6      	; 0x330 <readUsart+0xbc>
			p_buffer = &buffer[0]; // reset the point to the 0th index
 336:	f0 93 01 01 	sts	0x0101, r31	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 33a:	e0 93 00 01 	sts	0x0100, r30	; 0x800100 <__DATA_REGION_ORIGIN__>
			rxState = IDLE;
 33e:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <rxState>
 342:	08 95       	ret
		}
		else
		{
			p_buffer++;
 344:	31 96       	adiw	r30, 0x01	; 1
 346:	f0 93 01 01 	sts	0x0101, r31	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
 34a:	e0 93 00 01 	sts	0x0100, r30	; 0x800100 <__DATA_REGION_ORIGIN__>
 34e:	08 95       	ret

00000350 <sendUsart>:
	}
}

void sendUsart(char byte_to_send)
{
	while(txBufferFull); // Wait for tx buffer to be empty
 350:	90 91 c8 00 	lds	r25, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
 354:	95 ff       	sbrs	r25, 5
 356:	fc cf       	rjmp	.-8      	; 0x350 <sendUsart>
	UDR1 = byte_to_send; // Write data to txBuffer
 358:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
 35c:	08 95       	ret

0000035e <sendAdcUsart>:
}

void sendAdcUsart(char input_device)
{
	ADMUX = input_device; // Set ADC input device
 35e:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	startConversion;
 362:	ea e7       	ldi	r30, 0x7A	; 122
 364:	f0 e0       	ldi	r31, 0x00	; 0
 366:	80 81       	ld	r24, Z
 368:	80 64       	ori	r24, 0x40	; 64
 36a:	80 83       	st	Z, r24
	while(converisonRunning); // wait for conversion to complete
 36c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 370:	86 fd       	sbrc	r24, 6
 372:	fc cf       	rjmp	.-8      	; 0x36c <sendAdcUsart+0xe>
	char adc_val = ADCH; // Save converted ADC value
 374:	80 91 79 00 	lds	r24, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
	sendUsart(adc_val);
 378:	eb cf       	rjmp	.-42     	; 0x350 <sendUsart>
 37a:	08 95       	ret

0000037c <__tablejump2__>:
 37c:	ee 0f       	add	r30, r30
 37e:	ff 1f       	adc	r31, r31
 380:	00 24       	eor	r0, r0
 382:	00 1c       	adc	r0, r0
 384:	0b be       	out	0x3b, r0	; 59
 386:	07 90       	elpm	r0, Z+
 388:	f6 91       	elpm	r31, Z
 38a:	e0 2d       	mov	r30, r0
 38c:	09 94       	ijmp

0000038e <_exit>:
 38e:	f8 94       	cli

00000390 <__stop_program>:
 390:	ff cf       	rjmp	.-2      	; 0x390 <__stop_program>
